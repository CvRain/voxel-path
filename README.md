# Voxel Path: Artisan's Realm

这是一个基于 Godot 4 开发的高精度体素沙盒游戏项目。目标是构建一个拥有微体素（0.25m）、超高地形（1024高度限制）沉浸式建造世界。
本项目参考了很多知名的模组，比如“机械动力”，沉浸系列，匠魂等模组。我的世界是一款无法超越的沙盒游戏，我从中找到了不少灵感， 尝试制作一款以建造与机械相关的沙盒游戏。

## 🌟 项目愿景

- **微体素世界**：基础体素大小为 0.25m，允许极其精细的建筑和雕刻。
- **宏大地形**：支持 3072 格高度的垂直空间，配合 64x64x3072 的区块结构。

## 🚀 当前进度 (2025.11.24)

### 1. 核心体素引擎 (Voxel Engine)
- **Palette 系统 (调色板)**: 实现了类似 Minecraft 1.13+ 的 Palette 存储架构。
    - **内存优化**: 区块内仅存储 8-bit 的 Local Index，通过 Palette 映射到 Global State ID。
    - **无限扩展**: 支持理论上无限的方块类型，不再受限于 256 ID 上限。
- **方块状态 (Block States)**: 
    - 支持复杂的方块属性（如 `oxidization=2`, `facing=north`）。
    - 自动计算属性组合的笛卡尔积，生成唯一的 Global State ID。
    - 兼容旧的 Block ID 访问方式，保证开发便利性。
- **多线程网格生成**: 渲染任务在后台线程池执行，主线程仅负责提交数据快照，极大减少了卡顿。

### 2. 持久化系统 (Persistence)
- **存档/读档**: 实现了完整的世界状态保存。
    - **区块存储**: 使用二进制格式 + ZSTD 压缩，极大地减小了存档体积（稀疏矩阵思想）。
    - **玩家状态**: 保存玩家位置、朝向和头部角度。
- **无缝体验**: 游戏启动自动加载存档，支持游戏中按键手动保存/加载。
- **异步加载**: 实现了分帧加载机制，避免读档时 CPU 瞬间满载导致的画面卡死。

### 3. 世界生成 (World Gen)
- **基础地形**: 使用 `FastNoiseLite` 生成平滑的地形起伏。
- **植被系统**: 新增了橡木原木 (`oak_log`) 和树叶 (`oak_leaves`)。
- **装饰器 (Decorators)**: 实现了跨区块的装饰生成流程，支持简单的森林生物群系，树木可以自然地生长在区块边界上。

### 4. 玩家交互 (Interaction)
- **智能笔刷**:
    - **多尺寸切换**: 按 `Tab` 键切换 1x1 (0.25m), 2x2 (0.5m), 4x4 (1m) 笔刷。
    - **法线校正**: 放置方块时会自动根据点击面的法线方向向外延伸，确保方块完美贴合表面。
- **高亮系统**: 实时高亮显示当前笔刷覆盖的体素范围。

## 🎮 操作说明

- **W/A/S/D**: 移动
- **Space**: 跳跃 / 向上飞行
- **Shift**: 冲刺 / 向下飞行
- **F**: 切换飞行模式
- **V**: 切换穿墙 (Noclip) 模式
- **Tab**: 切换笔刷大小 (1x1 -> 2x2 -> 4x4)
- **K**: 保存世界 (Save)
- **L**: 加载世界 (Load)
- **鼠标左键**: 破坏方块
- **鼠标右键**: 放置方块

## 🛠️ 技术架构

### 目录结构
```
Scenes/
  PlayerController/    # 玩家逻辑、高亮、笔刷
  RandomWorld/         # 主游戏场景 (地形、存档管理)
Scripts/
  Voxel/               # 核心体素逻辑
    chunk.gd           # 区块存储与网格生成
    chunk_palette.gd   # 调色板映射 (Local Index <-> Global ID)
    block_state_registry.gd # 全局状态管理
  Persistence/         # 存档系统
    chunk_serializer.gd # 区块二进制序列化
    player_serializer.gd # 玩家状态 JSON 序列化
  Core/                # 基础工具
Data/
  blocks/              # 方块定义 JSON (支持 states 属性)
```

### 开发日志 (DevLog)
- **2025.11.24**: 
    - 完成了 **Block State** 系统的全链路集成。
    - 实现了 **ChunkSerializer**，支持二进制压缩存档。
    - 修复了笔刷放置时的嵌入问题，增加了法线偏移。
    - 优化了读档性能，引入异步分帧处理。
    - 添加了树木生成逻辑。

- **2025.11.22**: 
    - 实现了高亮框的 MultiMesh 渲染。
    - 优化了射线检测逻辑。


### todo
A. 区块碰撞体积与玩家距离判定
每个区块可添加一个简单的碰撞体（如 AABB），用于快速判定玩家是否进入/靠近该区块。
玩家移动时，实时检测其所在区块，动态调整需要加载/生成的区块列表。
B. 视距/模拟距离分层加载
视距范围内区块优先加载并生成基础地形（BASE_TERRAIN），模拟距离内区块再补充装饰/地区性方块。
玩家移动时，优先卸载远离视距的区块，释放内存和CPU。
C. Section异步生成与优先级
区块生成拆分为Section任务，优先生成玩家附近的Section（如地表、玩家所在高度），远离玩家的Section可延后或低优先级。
SectionManager已支持优先级枚举（HIGH/MEDIUM/LOW），可参考luanti的 emerge 机制，动态调整队列和线程数。
D. 线程池与任务队列
保持单独的地形生成线程池，主线程只负责写回和网格更新，避免SceneTree操作。
队列上限、动态线程数可参考luanti，结合CPU/内存自动调整。
E. 预测加载与卸载
玩家移动方向提前加载前方区块，提升体验。
超出_keep_distance的区块及时卸载，避免资源泄漏。

游戏打开开启调试模式，在栅格器项目中，我看到绘制图源数达到了恐怖的42万，这导致游戏项目，godot全部卡死了。
Mesh合并：将同一区块或相邻Section的Mesh批量合并为一个大Mesh，极大减少MeshInstance数量和DrawCall。
Section网格合并：每个Chunk只保留1~2个MeshInstance（如地表+水体），不再为每个Section单独创建MeshInstance。
装饰物合并/延迟生成：树木、花草等装饰物采用Instance合批或延迟生成，远离玩家的装饰物不生成或合并为低细节Mesh。
物理体限流：物理体仅为玩家附近区块生成，远离区块不生成或延迟生成。
主线程Mesh写回限流：每帧只允许有限Mesh写回，优先玩家视野内区块。

现在还是非常难受的状态，我运行了项目一分钟，获得了如下数据
栅格器：
绘制对象总数：203
绘制图元总数：5049706
绘制调用总数：203
时间
fps 2
处理 5.17ms
物理处理 1317.94ms

分析器：测量模式为物理帧
frame time 5999/3%
physics time: 3.9%
process time: 5995.4%
physics farme time: 100%
在这个过程中，显卡占用几乎是0% ，我怀疑所有的游戏内容都是cpu硬算的，按理来说生成的方块，可以将一个区块的内容都准备好，直接推送给显卡进行加速生成。
